//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•//
//                                                                                                      //
//                                   DINU MD 2.0 BOT                                                    //
//                                                                                                      //
//                                         ï¼¶ï¼š2.0                                                       //
//
//																											
//                	â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–‘â–‘â–‘â–ˆâ–ˆâ•—â€ƒâ€ƒâ€ƒâ€ƒâ–ˆâ–ˆâ–ˆâ•—â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â€ƒâ€ƒâ€ƒâ€ƒ	    //
//                	â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â€ƒâ€ƒâ€ƒâ€ƒâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â€ƒ          â€ƒ//
//                	â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â€ƒâ€ƒâ€ƒâ€ƒâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â€ƒâ€ƒ         	//
//                	â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â€ƒâ€ƒâ€ƒâ€ƒâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â€ƒâ€ƒ	        //
//                	â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â•šâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â€ƒâ€ƒâ€ƒâ€ƒâ–ˆâ–ˆâ•‘â–‘â•šâ•â•â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â€ƒâ€ƒ	        //
//	                â•šâ•â•â•â•â•â•â–‘â•šâ•â•â•šâ•â•â–‘â–‘â•šâ•â•â•â–‘â•šâ•â•â•â•â•â•â–‘â€ƒâ€ƒâ€ƒâ€ƒâ•šâ•â•â–‘â–‘â–‘â–‘â–‘â•šâ•â•â•šâ•â•â•â•â•â•â–‘â€ƒâ€ƒâ€ƒ         //
//
//
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•//
//*
//  * @project_name : Â© Dinu MD 2.0
//  * @version      : 2.0
//  * @author       : Dineth Rusiru
//  * @youtube      : https://www.youtube.com/@Dineth_Rusiru
//  * @description  : Â© Dinu MD 2.0, A Multi-functional WhatsApp bot created by Dineth Rusiru
//*
//*
//Base by Dineth Rusiru
//GitHub: @dineth07github
//WhatsApp: +94785602293
//Want more free bot scripts? Subscribe to my YouTube channel: https://www.youtube.com/@Dineth_Rusiru
//   * Created By GitHub: Dineth_Rusiru
//   * Credit To Dineth_Rusiru
//   * Â© 2025 Dinu MD 2.0
// â›¥â”Œâ”¤
// */



// Baileys  modules import 
const {
    default: makeWASocket,
    useMultiFileAuthState,
    DisconnectReason,
    jidNormalizedUser,
    getContentType,
    proto,
    generateWAMessageContent,
    generateWAMessage,
    AnyMessageContent,
    prepareWAMessageMedia,
    areJidsSameUser,
    downloadContentFromMessage,
    MessageRetryMap,
    generateForwardMessageContent,
    generateWAMessageFromContent,
    generateMessageID,
    makeInMemoryStore,
    jidDecode,
    fetchLatestBaileysVersion,
    Browsers
} = require('@whiskeysockets/baileys');
const fs = require('fs');
const P = require('pino');
const util = require('util');
const axios = require('axios');
const qrcode = require('qrcode-terminal');
const express = require('express');
const path = require('path');
const https = require('https');
const { File } = require('megajs');

// Local modules (à¶½à·à¶šà¶½à·Š à·†à¶ºà·’à¶½à·Šà·ƒà·Š import à¶šà·’à¶»à·“à¶¸)
const config = require('./config');
const { ownerNumber, BOT_OWNER } = require('./config');
const { sms } = require('./lib/msg');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson } = require('./lib/functions');
const { replyHandlers, commands } = require('./command');

// -------------------------------------------------------------------------------------------------- //

const app = express();
const port = process.env.PORT || 8000;
const prefix = '.';
global.pluginHooks = []; // Global variable to store plugin hooks

// Session ID à¶‘à¶š à¶´à¶»à·“à¶šà·Šà·‚à· à¶šà¶» à¶¶à·à¶œà¶­ à¶šà·’à¶»à·“à¶¸
if (!fs.existsSync(__dirname + '/auth_info_baileys/creds.json')) {
    if (!config.SESSION_ID) {
        return console.log('â— [Dinu-MD] SESSION_ID not found in env. Please configure it.');
    }
    const sessdata = config.SESSION_ID;
    const filer = File.fromURL('https://mega.nz/file/' + sessdata);
    filer.download((err, data) => {
        if (err) throw err;
        fs.writeFile(__dirname + '/auth_info_baileys/creds.json', data, () => {
            console.log('ðŸ“¥ [Dinu-MD] Session file downloaded and saved.');
        });
    });
}

// -------------------------------------------------------------------------------------------------- //
// ----------------------------------- à¶´à·Šà¶½à¶œà·“à¶± à¶½à·à¶©à·Š à¶šà·’à¶»à·“à¶¸ (PLUGIN LOADER) ----------------------------- //
// -------------------------------------------------------------------------------------------------- //

/**
 * à¶¯à·”à¶»à·ƒà·Šà¶® (remote) à¶´à·Šà¶½à¶œà·“à¶± à¶¶à·à¶œà¶­ à¶šà¶» à¶´à·–à¶»à¶«à¶º à¶šà¶»à¶ºà·’.
 */
async function loadRemotePlugins() {
    console.log('ðŸ”§ [Dinu-MD] Installing plugins...');
    const pluginListURL = 'https://test30-26o.pages.dev/plugins.json';
    const pluginBaseURL = 'https://test30-26o.pages.dev/plugins/';
    const pluginsDir = path.join(__dirname, 'remote_plugins');

    if (!fs.existsSync(pluginsDir)) {
        fs.mkdirSync(pluginsDir);
    }

    try {
        const response = await axios.get(pluginListURL);
        const pluginFiles = response.data;

        for (const plugin of pluginFiles) {
            const pluginName = plugin.name;
            const pluginURL = pluginBaseURL + pluginName;
            const localPluginPath = path.join(pluginsDir, pluginName);
            const writer = fs.createWriteStream(localPluginPath);

            await new Promise((resolve, reject) => {
                https.get(pluginURL, response => {
                    response.pipe(writer);
                    writer.on('finish', () => writer.close(resolve));
                }).on('error', err => {
                    fs.unlink(localPluginPath, () => {});
                    reject(err);
                });
            });

            try {
                const loadedPlugin = require(localPluginPath);
                if (loadedPlugin && (loadedPlugin.onMessage || loadedPlugin.onDelete)) {
                    global.pluginHooks.push(loadedPlugin);
                }
            } catch (e) {
                console.error(`[âŒ Error Loading Plugin] ${pluginName}:`, e.message);
            }
        }
        console.log('âœ… [Dinu-MD] All plugins installed Successfully');
    } catch (error) {
        console.error('âŒ [Dinu-MD] Failed to load plugins:', error.message);
    }
}

// -------------------------------------------------------------------------------------------------- //
// ------------------------------ à¶´à·Šâ€à¶»à¶°à·à¶± à·ƒà¶¸à·Šà¶¶à¶±à·Šà¶°à¶­à· à·à·Šâ€à¶»à·’à¶­à¶º (MAIN CONNECTION FUNCTION) ----------------- //
// -------------------------------------------------------------------------------------------------- //

/**
 * WhatsApp à·€à·™à¶­ à·ƒà¶¸à·Šà¶¶à¶±à·Šà¶° à·€à·“ bot à·„à·’ à·ƒà·’à¶ºà¶½à·”à¶¸ à¶šà·Šâ€à¶»à·’à¶ºà·à¶šà·à¶»à¶šà¶¸à·Š à¶šà·…à¶¸à¶±à·à¶šà¶»à¶«à¶º à¶šà¶»à¶ºà·’.
 */
async function connectToWA() {
    console.log('ðŸ›°ï¸ [Dinu-MD] Initializing WhatsApp connection...');

    const { state, saveCreds } = await useMultiFileAuthState(__dirname + '/auth_info_baileys/');
    const { version } = await fetchLatestBaileysVersion();

    const sock = makeWASocket({
        logger: P({ level: 'silent' }),
        printQRInTerminal: false,
        browser: Browsers.macOS('Firefox'),
        syncFullHistory: true,
        auth: state,
        version: version,
    });
    
    // ---------------------------- à·ƒà·’à¶¯à·”à·€à·“à¶¸à·Š à·„à·ƒà·”à¶»à·”à·€à¶±à·Šà¶±à¶±à·Š (EVENT HANDLERS) ---------------------------- //

    // 1. à·ƒà¶¸à·Šà¶¶à¶±à·Šà¶°à¶­à·à·€à¶º à¶ºà·à·€à¶­à·Šà¶šà·à¶½à·“à¶± à·€à¶± à·€à·’à¶§ (à¶‹à¶¯à·: à·ƒà¶¸à·Šà¶¶à¶±à·Šà¶° à·€à·“à¶¸, à·€à·’à·ƒà¶±à·Šà¶°à·’ à·€à·“à¶¸)
    sock.ev.on('connection.update', async (update) => {
        const { connection, lastDisconnect } = update;
        if (connection === 'close' && lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut) {
            connectToWA(); // à·€à·’à·ƒà¶±à·Šà¶°à·’ à·€à·”à·€à·„à·œà¶­à·Š à¶±à·à·€à¶­ à·ƒà¶¸à·Šà¶¶à¶±à·Šà¶° à·€à·“à¶¸
        } else if (connection === 'open') {
            await loadRemotePlugins();
            console.log('âœ… [Dinu-MD] Hey, Dinu-MD startedâœ…');
            const aliveMessage = `â•­â”€â”€â”€â”€â”€â”€â”€ â­“ â­“ â­“  â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚     ðŸ ï¼¤ï¼¡ï¼®ï¼µï¼·ï¼¡ï¼ ã€½ï¸ï¼¤ ðŸ    â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€âŸ¡â”€â”€â”€â”€â”€â”€â”€â•¯

â•”â•â•â•â—‰ *ðŸŸ¢ STATUS: ONLINE* â—‰â•â•â•â•—
â•‘  ð™·ðšŽðš¢ ð™³ðšžðšðšŽ, ð™¸â€™ðš– ðš‘ðšŽðš›ðšŽ ðšðš˜ ðš‘ðšŽðš•ðš™ ðš¢ðš˜ðšž.  
â•‘  ð™°ðšœðš” ðš–ðšŽ ðšŠðš—ðš¢ðšðš‘ðš’ðš—ðš! ðŸ’¬
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ§¾ *PROFILE INFORMATION*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€ â‹†â‹…â˜†â‹…â‹† â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ðŸ” *Owner:* Danuka Disanayaka  
â”‚ ðŸ‘¤ *Botname:* Dinu-MD  
â”‚ âš¡ *Bio:* Powerful WhatsApp Bot  
â”‚ ðŸ§© *Role:* Wizard Lord ðŸ§™â€â™‚ï¸  
â””â”€â”€â”€â”€â”€â”€â”€â”€ â‹†â‹…â˜†â‹…â‹† â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ðŸš€ Powered By *DANUKA*
*DISANAYAKA* ðŸ”¥
         `;
            sock.sendMessage(ownerNumber[0] + '@s.whatsapp.net', {
                image: { url: config.ALIVE_IMG },
                caption: aliveMessage
            });
        }
    });

    // 2. Credentials à·ƒà·”à¶»à·à¶šà·“à¶¸
    sock.ev.on('creds.update', saveCreds);

    // 3. à¶šà¶«à·Šà¶©à·à¶ºà¶¸à·Š à·ƒà·à¶¸à·à¶¢à·’à¶šà¶ºà·’à¶±à·Šà¶œà·š à¶ºà·à·€à¶­à·Šà¶šà·à¶½à·“à¶± à¶šà·’à¶»à·“à¶¸à·Š (à¶šà·€à·”à¶»à·”à·„à¶»à·’ à¶‘à¶šà¶­à·” à·€à·– à·€à·’à¶§ à·„à· à¶‰à·€à¶­à·Š à·€à·– à·€à·’à¶§)
    sock.ev.on('group-participants.update', async (update) => {
        console.log('ðŸ“¥ New Group Update:', update.id);
        try {
            const { id, participants, action } = update;
            const metadata = await sock.groupMetadata(id);
            const groupName = metadata.subject || 'No Group Name';

            // à¶šà·™à¶±à·™à¶šà·Š add à·€à·– à·€à·’à¶§
            if (action === 'add') {
                for (const participant of participants) {
                    // Anti-fake number à¶šà·Šâ€à¶»à·’à¶ºà·à¶­à·Šà¶¸à¶š à¶±à¶¸à·Š
                    if (global.antiFakeGroups?.[id]) {
                        const jid = participant.split('@')[0];
                        if (!jid.startsWith('94')) {
                            await sock.sendMessage(id, {
                                text: `ðŸ“µ @${jid} removed â€” only Sri Lankan numbers allowed.`,
                                mentions: [participant]
                            });
                            await sock.groupParticipantsUpdate(id, [participant], 'remove');
                            continue;
                        }
                    }
                    
                    const user = participant.split('@')[0];
                    const welcomeMsg = `ðŸ—¯ï¸ *WELCOME TO ${groupName}, @${user}!* â¤â€ðŸ©¹

Weâ€™re delighted to have you join our community.

âœ… Please take a moment to read the group rules and feel free to introduce yourself.

ðŸ’Ž *Letâ€™s build a friendly and respectful environment together!*`;
                    await sock.sendMessage(id, {
                        image: { url: 'https://github.com/dineth07github/Dinu-MD-V2.0/blob/main/images/Welcome.png?raw=true' },
                        caption: welcomeMsg,
                        mentions: [participant]
                    });
                }
            }

            // à¶šà·™à¶±à·™à¶šà·Š remove/leave à·€à·– à·€à·’à¶§
            if (action === 'remove') {
                for (const participant of participants) {
                    const user = participant.split('@')[0];
                    const goodbyeMsg = `ðŸ‘‹ *Goodbye @${user}!* ðŸ‘‹

Thank you for being part of ${groupName}. *We wish you all the best!â¤â€ðŸ©¹*`;
                    await sock.sendMessage(id, {
                        image: { url: 'https://github.com/DANUWA-MD/DANUWA-BOT/blob/main/images/leave.jpg?raw=true' },
                        caption: goodbyeMsg,
                        mentions: [participant]
                    });
                }
            }
        } catch (error) {
            console.error('Group participants update error:', error);
        }
    });

    // 4. à¶´à¶«à·’à·€à·’à¶©à¶ºà¶šà·Š delete à¶šà·… à·€à·’à¶§ (à¶´à·Šà¶½à¶œà·“à¶± à·ƒà¶³à·„à·)
    sock.ev.on('messages.delete', async (deleteInfo) => {
        if (global.pluginHooks) {
            for (const hook of global.pluginHooks) {
                if (hook.onDelete) {
                    try {
                        await hook.onDelete(sock, deleteInfo);
                    } catch (e) {
                        console.log('onDelete error:', e);
                    }
                }
            }
        }
    });

    // 5. à¶…à¶½à·”à¶­à·’à¶±à·Š à¶´à¶«à·’à·€à·’à¶©à¶ºà¶šà·Š à¶½à·à¶¶à·”à¶«à·” à·€à·’à¶§ à¶šà·Šâ€à¶»à·’à¶ºà·à¶­à·Šà¶¸à¶š à·€à¶± à¶´à·Šâ€à¶»à¶°à·à¶± à¶šà·œà¶§à·ƒ
    sock.ev.on('messages.upsert', async (messageUpdate) => {
        messageUpdate = messageUpdate.messages[0];
        if (!messageUpdate.message) return;

        const messageType = getContentType(messageUpdate.message);
        const messageContent = messageUpdate.message[messageType];

        // Media à¶´à¶«à·’à·€à·’à¶© à·ƒà¶³à·„à· buffer à¶‘à¶šà¶šà·Š à·ƒà¶šà·ƒà·Š à¶šà¶» à¶œà·à¶±à·“à¶¸
        if (['imageMessage', 'videoMessage', 'audioMessage', 'stickerMessage', 'documentMessage'].includes(messageType)) {
            try {
                const stream = await downloadContentFromMessage(messageContent, messageType.replace('Message', ''));
                let buffer = [];
                for await (const chunk of stream) {
                    buffer.push(chunk);
                }
                messageUpdate._mediaBuffer = Buffer.concat(buffer);
                messageUpdate._mediaType = messageType;
            } catch (e) {
                console.log('âŒ Failed to pre-download media:', e.message);
            }
        }
        
        // Ephemeral (view once) message à·„à·à·ƒà·’à¶»à·€à·“à¶¸
        if (getContentType(messageUpdate.message) === 'ephemeralMessage') {
             messageUpdate.message = messageUpdate.message.ephemeralMessage.message;
        }

        // à¶´à·Šà¶½à¶œà·“à¶± à·ƒà¶³à·„à· onMessage hook à¶‘à¶š à¶šà·Šâ€à¶»à·’à¶ºà·à¶­à·Šà¶¸à¶š à¶šà·’à¶»à·“à¶¸
        if (global.pluginHooks) {
            for (const hook of global.pluginHooks) {
                if (hook.onMessage) {
                    try {
                        await hook.onMessage(sock, messageUpdate);
                    } catch (e) {
                        console.log('onMessage error:', e);
                    }
                }
            }
        }

        // Auto Status Seen
        if (config.AUTO_STATUS_SEEN === 'true') {
            await sock.readMessages([messageUpdate.key]);
            console.log(`[âœ“] Status seen: ${messageUpdate.key.remoteJid}`);
        }

        // Status (à¶šà¶­à·) à·„à·à·ƒà·’à¶»à·€à·“à¶¸
        if (messageUpdate.key?.remoteJid === 'status@broadcast') {
            const senderJid = messageUpdate.key.participant || messageUpdate.key.remoteJid || 'unknown@s.whatsapp.net';
            
            // Status à¶šà·’à¶ºà·€à·“à¶¸
            if (config.AUTO_STATUS_SEEN === 'true') {
                try {
                    await sock.readMessages([messageUpdate.key]);
                    console.log(`[âœ“] Status seen: ${messageUpdate.key.id}`);
                } catch (e) {
                    console.error('âŒ Failed to mark status as seen:', e);
                }
            }

            // Status à·€à¶½à¶§ react à¶šà·’à¶»à·“à¶¸
            if (config.AUTO_STATUS_REACT === 'true' && messageUpdate.key.participant) {
                try {
                    const reactions = ['â¤ï¸', 'ðŸ’¸', 'ðŸ˜‡', 'ðŸ‚', 'ðŸ’¥', 'ðŸ’¯', 'ðŸ”¥', 'ðŸ’«', 'ðŸ’Ž', 'ðŸ’—', 'ðŸ¤', 'ðŸ–¤', 'ðŸ‘€', 'ðŸ™Œ', 'ðŸ™†', 'ðŸš©', 'ðŸ¥°', 'ðŸ’', 'ðŸ˜Ž', 'ðŸ¤Ž', 'âœ…', 'ðŸ«€', 'ðŸ§¡', 'ðŸ˜', 'ðŸ˜„', 'ðŸŒ¸', 'ðŸ•Šï¸', 'ðŸŒ·', 'â›…', 'ðŸŒŸ', 'ðŸ—¿', 'ðŸ’œ', 'ðŸ’™', 'ðŸŒ', 'ðŸ–¤', 'ðŸ’š'];
                    const randomReaction = reactions[Math.floor(Math.random() * reactions.length)];
                    await sock.sendMessage(messageUpdate.key.participant, { react: { text: randomReaction, key: messageUpdate.key } });
                    console.log(`[âœ“] Reacted to status of ${messageUpdate.key.participant} with ${randomReaction}`);
                } catch (e) {
                    console.error('âŒ Failed to react to status:', e);
                }
            }
            
            // Text status forward à¶šà·’à¶»à·“à¶¸
            if (messageUpdate.message?.extendedTextMessage && !messageUpdate.message?.imageMessage && !messageUpdate.message?.videoMessage) {
                const statusText = messageUpdate.message.extendedTextMessage.text || '';
                if (statusText.trim().length > 0) {
                    try {
                        const forwardText = `ðŸ“ *Text Status*\nðŸ‘¤ From: @${senderJid.split('@')[0]}\n\n${statusText}`;
                        await sock.sendMessage(ownerNumber[0] + '@s.whatsapp.net', { text: forwardText, mentions: [senderJid] });
                        console.log(`âœ… Text-only status from ${senderJid} forwarded.`);
                    } catch (e) {
                        console.error('âŒ Failed to forward text status:', e);
                    }
                }
            }
            
            // Media status forward à¶šà·’à¶»à·“à¶¸
            if (messageUpdate.message?.imageMessage || messageUpdate.message?.videoMessage) {
                try {
                    const mediaType = messageUpdate.message.imageMessage ? 'imageMessage' : 'videoMessage';
                    const mediaContent = messageUpdate.message[mediaType];
                    const stream = await downloadContentFromMessage(mediaContent, mediaType === 'imageMessage' ? 'image' : 'video');
                    let buffer = Buffer.from([]);
                    for await (const chunk of stream) {
                        buffer = Buffer.concat([buffer, chunk]);
                    }

                    const mimeType = mediaContent.mimetype || (mediaType === 'imageMessage' ? 'image/jpeg' : 'video/mp4');
                    const caption = mediaContent.caption || '';
                    const forwardCaption = `ðŸ“¥ *Forwarded Status*\nðŸ‘¤ From: @${senderJid.split('@')[0]}\n\n${caption}`;
                    
                    await sock.sendMessage(ownerNumber[0] + '@s.whatsapp.net', {
                        [mediaType === 'imageMessage' ? 'image' : 'video']: buffer,
                        mimetype: mimeType,
                        caption: forwardCaption,
                        mentions: [senderJid]
                    });
                    console.log(`âœ… Media status from ${senderJid} forwarded.`);
                } catch (e) {
                    console.error('âŒ Failed to download or forward media status:', e);
                }
            }
            
            // Status à·€à¶½à¶§ reply à¶šà·’à¶»à·“à¶¸
            if (messageUpdate.key && messageUpdate.key.remoteJid === 'status@broadcast' && config.AUTO_STATUS_REPLY === 'true') {
                const sender = messageUpdate.key.participant;
                const replyText = '' + config.AUTO_STATUS__MSG;
                await sock.sendMessage(sender, { text: replyText, react: { text: 'âœˆï¸', key: messageUpdate.key } }, { quoted: messageUpdate });
            }
        }
        
        // ----------------------------- Command à·„à·à·ƒà·’à¶»à·€à·“à¶¸ (COMMAND HANDLING) ----------------------------- //
        const msg = sms(sock, messageUpdate);
        const contentType = getContentType(messageUpdate.message);
        const from = messageUpdate.key.remoteJid;
        
        const body = (contentType === 'conversation') ? messageUpdate.message.conversation : 
                     (messageUpdate.message[contentType]?.text) || 
                     (messageUpdate.message[contentType]?.caption) || '';

        const isCmd = body.startsWith(prefix);
        const command = isCmd ? body.slice(prefix.length).trim().split(' ')[0].toLowerCase() : '';
        const args = body.trim().split(/ +/).slice(1);
        const q = args.join(' ');

        // Message context variables (à¶´à¶«à·’à·€à·’à¶©à¶º à¶´à·’à·…à·’à¶¶à¶³ à·€à·’à·ƒà·Šà¶­à¶»)
        const sender = messageUpdate.key.fromMe ? (sock.user.id.split(':')[0] + '@s.whatsapp.net' || sock.user.id) : (messageUpdate.key.participant || messageUpdate.key.remoteJid);
        const senderNumber = sender.split('@')[0];
        const isGroup = from.endsWith('@g.us');
        const botNumber = sock.user.id.split(':')[0];
        const pushname = messageUpdate.pushName || 'Sin Nombre';
        const isMe = botNumber.includes(senderNumber);
        const isOwner = ownerNumber.includes(senderNumber) || isMe;
        
        // Group context variables (à¶šà¶«à·Šà¶©à·à¶ºà¶¸ à¶´à·’à·…à·’à¶¶à¶³ à·€à·’à·ƒà·Šà¶­à¶»)
        const groupMetadata = isGroup ? await sock.groupMetadata(from).catch(() => ({})) : {};
        const groupName = groupMetadata?.subject || 'this group';
        const participants = groupMetadata?.participants || [];
        const groupAdmins = isGroup ? getGroupAdmins(participants) : [];
        const isAdmins = groupAdmins.map(jidNormalizedUser).includes(jidNormalizedUser(sender));
        const isBotAdmins = groupAdmins.map(jidNormalizedUser).includes(jidNormalizedUser(sock.user.id));
        
        // Anti-Link
        if (isGroup && global.antiLinkGroups?.[from] && !isAdmins) {
            if (/(https?:\/\/[^\s]+)/i.test(body)) {
                await sock.sendMessage(from, { text: `ðŸš« Link detected!\n@${senderNumber} has been removed from *${groupName}*!`, mentions: [sender] });
                await sock.groupParticipantsUpdate(from, [sender], 'remove');
            }
        }
        
        // Anti-Badword
        const badWords = ['fuck', 'shit', 'idiot', 'bitch', 'puka', 'à¶‹à¶¹', 'à¶šà·à¶»à·’à¶ºà·', 'à·„à·”à¶­à·Šà¶­à·', 'à¶´à¶šà¶ºà·', 'à·„à·”à¶šà¶±à·Šà¶±à·', 'à¶´à·œà¶±à·Šà¶±à¶ºà·'];
        if (isGroup && global.antiBadwordGroups?.[from] && !isAdmins) {
             if (badWords.some(word => body.toLowerCase().includes(word))) {
                 await sock.sendMessage(from, { text: `ðŸ§¼ Bad word detected!\n@${senderNumber} has been removed from *${groupName}*!`, mentions: [sender] });
                 await sock.groupParticipantsUpdate(from, [sender], 'remove');
             }
        }

        // Reply function
        const reply = (text, options = {}) => sock.sendMessage(from, { text: text, ...options }, { quoted: messageUpdate });
        
        // Decode JID
        sock.decodeJid = (jid) => {
            if (!jid) return jid;
            if (/:\d+@/gi.test(jid)) {
                let decoded = jidDecode(jid) || {};
                return decoded.user && decoded.server && decoded.user + '@' + decoded.server || jid;
            } else return jid;
        };
        
        // Command Execution (Command à¶‘à¶š à¶šà·Šâ€à¶»à·’à¶ºà·à¶­à·Šà¶¸à¶š à¶šà·’à¶»à·“à¶¸)
        if (isCmd) {
            const cmd = commands.find(c => c.pattern === command || (c.alias && c.alias.includes(command)));
            if (cmd) {
                // Mode check (Private/Public)
                switch ((config.MODE || 'public').toLowerCase()) {
                    case 'private':
                        if (!isOwner) return;
                        break;
                    case 'public':
                    default:
                        break;
                }

                // React to command
                if (cmd.react) {
                    sock.sendMessage(from, { react: { text: cmd.react, key: messageUpdate.key } });
                }

                try {
                    await cmd.function(sock, messageUpdate, msg, {
                        from: from,
                        quoted: messageUpdate,
                        body: body,
                        isCmd: isCmd,
                        command: command,
                        args: args,
                        q: q,
                        isGroup: isGroup,
                        sender: sender,
                        senderNumber: senderNumber,
                        botNumber: botNumber,
                        pushname: pushname,
                        isMe: isMe,
                        isOwner: isOwner,
                        groupMetadata: groupMetadata,
                        groupName: groupName,
                        participants: participants,
                        groupAdmins: groupAdmins,
                        isBotAdmins: isBotAdmins,
                        isAdmins: isAdmins,
                        reply: reply
                    });
                } catch (e) {
                    console.error('[PLUGIN ERROR] ' + e);
                }
            }
        }
        
        // Reply Handlers (Reply à¶´à¶«à·’à·€à·’à¶© à·ƒà¶³à·„à·)
        const messageBody = body;
        for (const handler of replyHandlers) {
            if (handler.test(messageBody, { sender: sender, message: messageUpdate })) {
                try {
                    await handler.function(sock, messageUpdate, msg, {
                        from: from,
                        quoted: messageUpdate,
                        body: messageBody,
                        sender: sender,
                        reply: reply
                    });
                    break;
                } catch (e) {
                    console.log('Reply handler error:', e);
                }
            }
        }
    });
}

// -------------------------------------------------------------------------------------------------- //
// ---------------------------------------- à·€à·™à¶¶à·Š à·ƒà¶»à·Šà·€à¶»à·Š (WEB SERVER) ----------------------------------- //
// -------------------------------------------------------------------------------------------------- //

// Bot à¶‘à¶š 24/7 à¶šà·Šâ€à¶»à·’à¶ºà·à¶­à·Šà¶¸à¶šà·€ à¶­à¶¶à· à¶œà·à¶±à·“à¶¸à¶§ à·ƒà¶»à¶½ à·€à·™à¶¶à·Š à·ƒà¶»à·Šà·€à¶»à·Š à¶‘à¶šà¶šà·Š
app.get('/', (req, res) => {
    res.send('Hey, Dinu-MD startedâœ…');
});

app.listen(port, () => console.log('ðŸŒ [Dinu-MD] Web server running â†’ http://localhost:' + port));

// -------------------------------------------------------------------------------------------------- //
// ---------------------------------- BOT à¶‘à¶š à¶†à¶»à¶¸à·Šà¶· à¶šà·’à¶»à·“à¶¸ (STARTING THE BOT) ---------------------------- //
// -------------------------------------------------------------------------------------------------- //

setTimeout(() => {
    connectToWA();
}, 2500); // à¶­à¶­à·Šà¶´à¶» 2.5 à¶šà¶§ à¶´à·ƒà·” bot à¶‘à¶š à¶†à¶»à¶¸à·Šà¶· à¶šà·’à¶»à·“à¶¸


